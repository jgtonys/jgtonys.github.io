<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="naver-site-verification" content="046c0adddf4769b5ef392d86e11c8d31a979c621"/>

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- Twitter Cards -->
	<meta name="twitter:title" content="알고리즘 - 그래프">
	<meta name="twitter:description" content="알고리즘 문제에서 가장 기본이 되고 가장 중요한 그래프와 BFS 에 관한 개념 문제이다. 로직을 알고 있더라도 까먹는 경우가 발생하므로 반드시 코드의 구조를 익숙한 방식으로 암기하는 것이 중요하다.

">
	
	
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:image" content="https://user-images.githubusercontent.com/33674947/56813408-d1b1d400-6877-11e9-9b4f-893fcc6254c6.jpg">
	

	<!-- Open Graph -->
	<meta property="og:locale" content="">
	<meta property="og:type" content="article">
	<meta property="og:title" content="알고리즘 - 그래프">
	
	<meta name="og:image" content="https://user-images.githubusercontent.com/33674947/56813408-d1b1d400-6877-11e9-9b4f-893fcc6254c6.jpg">
	

	<meta property="og:description" content="알고리즘 문제에서 가장 기본이 되고 가장 중요한 그래프와 BFS 에 관한 개념 문제이다. 로직을 알고 있더라도 까먹는 경우가 발생하므로 반드시 코드의 구조를 익숙한 방식으로 암기하는 것이 중요하다.

">
	<meta property="og:url" content="http://0.0.0.0:4000/algorithm/2019/07/18/algorithm(4)/">
	<meta property="og:site_name" content="Jungyu Kim">


  <title>
    
      알고리즘 - 그래프 &middot; Jungyu Kim
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/main.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <script src="https://code.jquery.com/jquery-3.4.0.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>

  
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"> </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
  </script>
  
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="sidebar-personal-info">
      <div class="sidebar-personal-info-section">
        <a href="https://github.com/jgtonys">
          <p><strong>Jungyu Kim</strong>
          <i class="fa fa-github" aria-hidden="true"></i></p>
        </a>
        </a>
      </div>
      <div class="sidebar-personal-info-section">
        <p>Wanted to be a <strong>developer</strong><br>And I <strong>am a developer</strong></p>
      </div>
      
      
      
      <div class="sidebar-personal-info-section">
        <p> Contact: 
        
        
        
        <a href="https://github.com/jgtonys">
          <i class="fa fa-github" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="https://facebook.com/jgtony">
          <i class="fa fa-facebook" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="http://www.google.com/recaptcha/mailhide/d?k=01I3lZFiZYng9N3QxYEtsDaQ==&c=31wAnZkuKqcG0ATAqJN8Z3ln5kkYLA9TwkGc-IbygpM=">
          <i class="fa fa-envelope" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="http://www.linkedin.com/in/준규-김-devj">
          <i class="fa fa-linkedin" aria-hidden="true"></i>
        </a>
        
        
        
        </p>
      </div>
      
    </div>
  </div>

  <nav class="sidebar-nav">
    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/">
          Home
        </a>

        
      </span>

    
      
      
      

      

      <span class="foldable">
        <a class="sidebar-nav-item " href="/blog/">
          Blog
        </a>

        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/categories/">
                Categories
              </a>
          
        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/tags/">
                Tags
              </a>
          
        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/about/">
          About
        </a>

        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="http://github.com/jgtonys/">
          Github Project
        </a>

        
      </span>

    

    <!--<span class="sidebar-nav-item">Currently v1.0.0</span>-->
  </nav>

  <div class="sidebar-item">
    <p>
    &copy; 2019 Jungyu Kim.
    </p>
  </div>

  <div class="sidebar-item">
    <p>
    Powered by <a href="http://jekyllrb.com">jekyll</a>
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home" title="Jungyu Kim">
              <!--<img class="masthead-logo" src="/public/logo.jpg"/>-->
              <strong>Jgtony</strong>
            </a>
            <small>Developer blog</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <span class="post-date">18 Jul 2019</span>
  <h1 class="post-title">알고리즘 - 그래프</h1>
  
  <div class="post-div">
    
    <a href="/blog/tags/#c" class="post-tag">c++</a>
    
  </div>
  
  <article>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <p>알고리즘 문제에서 가장 기본이 되고 가장 중요한 그래프와 BFS 에 관한 개념 문제이다. 로직을 알고 있더라도 까먹는 경우가 발생하므로 반드시 코드의 구조를 익숙한 방식으로 암기하는 것이 중요하다.</p>

<!-- more -->

<h3 id="그래프-문제를-푸는-접근법">그래프 문제를 푸는 접근법</h3>

<ol>
  <li>인접행렬을 구한다 : 모든 관계를 모든 행렬로 표현한다</li>
  <li>인접리스트를 구한다 : 한 정점에서 갈수있는 노드들을 행렬로 저장한다.</li>
</ol>

<p>대부분 인접리스트를 구하는 것이 cost 가 적게 들기 때문에, 문제에서 직접 행렬을 제시해준 경우 빼고는 인접리스트로 풀도록 하자.</p>

<p><br />
<br /></p>

<hr />

<h3 id="bfs와-dfs-1260번-문제">BFS와 DFS (1260번 문제)</h3>

<p>전형적으로 BFS와 DFS를 구하는 문제이다.</p>

<p>먼저 상대적으로 쉬운 DFS는 다음과 같은 특징을 암기하자.</p>

<p><strong>DFS</strong></p>

<ul>
  <li>기본적으로 재귀함수를 사용해서 푼다</li>
  <li>하나의 노드로부터 갈수있는 모든 노드로 dfs 를 돌린다</li>
</ul>

<p><em>여기에서 “갈수있는” 이라는 뜻은, 이미 지나왔던 노드인지 확인하는 것이다</em></p>

<p>즉 코드는 다음과 같은 형태를 띄게 된다</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 이제 이 노드를 돌기 때문에 check 해준다</span>
    <span class="n">check</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// a는 인접리스트가 저장되어 있다(a[start]의 사이즈만큼 돌린다)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 아직 방문하지 않은 점이라면, 방문한다</span>
        <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br /></p>

<p><strong>BFS</strong></p>

<ul>
  <li>queue 를 사용해서 앞에 있는 queue.front() 부터 시작한다.</li>
  <li>while(!q.empty()) 를 사용해서 queue 가 비어질때까지 반복한다.</li>
</ul>

<p><strong>여기서 중요한 점은 시작점을 queue 에 넣어야 한다는 것이다</strong></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;queue&gt;
</span><span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">check</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">front</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">front</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">check</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>

<hr />

<h3 id="연결요소의-개수11724번-문제">연결요소의 개수(11724번 문제)</h3>

<p>그래프에서 이어져 있는 그룹을 연결 요소라고 한다. 어떤 그래프를 보고 연결 요소의 개수를 구하는 문제이다.</p>

<p>이 문제 같은 경우, BFS 또는 DFS 를 몇번 돌려야만, 모든 노드들이 모두 check 되는지를 확인하면 된다.</p>

<p><strong>코드는 다음과 같다</strong></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// 메인 함수에서 처음부터 dfs 를 loop 로 돌린다</span>
<span class="kt">int</span> <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">ct</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">ct</span><span class="p">);</span></code></pre></figure>

<p><br />
<br /></p>

<hr />

<h3 id="이분그래프1707">이분그래프(1707)</h3>

<p>이분그래프는 하나의 정점에서 다른 정점으로 이동할때, 확실히 <code class="highlighter-rouge">다른 그룹</code> 이어야 한다는 것이다. 즉 색으로 표시하자면 빨강 정점은 항상 파랑 정점과 이어져 있고, 파랑 정점은 항상 빨강 정점과 이어져 있다는 것이다.</p>

<p>이 문제에서 그래프가 이분 그래프인지를 알아보려면, 재귀 dfs 를 사용할때 현재 정점에 색을 칠하고, 다음으로 가는 정점에 파란색을 칠하는 과정을 수행해야 한다.</p>

<p>기존에 check 배열이 true 와 false 만을 가졌다면, 이제는 0(지나지 않음), 1(빨강), 2(파랑) 으로 체크해주면 된다. 그리고 마지막에 더이상 갈 정점이 없을 때, 이어져 있는 정점이 현재 색과 다른 점인지를 확인해 주면 된다. 만약 모두 번갈아서 나온다면 이분 그래프가 맞다.</p>

<p><br /></p>

<p><strong>주의! 여러 테스트 케이스가 진행될 때마다 전역 변수 <code class="highlighter-rouge">check</code> 와 인접리스트 <code class="highlighter-rouge">a</code> 는 초기화를 시켜 주어야 한다. 또한 이 그래프는 연결요소가 몇개 있는지 모르기 때문에 모든 경우의 dfs 또는 bfs 를 구해 보아야 한다.</strong></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">20001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">check</span><span class="p">[</span><span class="mi">20001</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span><span class="kt">int</span> <span class="n">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">check</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="mi">3</span><span class="o">-</span><span class="n">color</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">k</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">v</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
            <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">e</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>
            <span class="n">a</span><span class="p">[</span><span class="n">v1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v2</span><span class="p">);</span>
            <span class="n">a</span><span class="p">[</span><span class="n">v2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">v</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">v</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">check</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])</span> <span class="p">{</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">flag</span><span class="o">?</span> <span class="s">"YES"</span><span class="o">:</span><span class="s">"NO"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><strong>특히나 이 문제에서 주의해야 할 점은, 마지막에 모든 인접 리스트를 검사해서 a[i] 에 있는 모든 원소들의 색이 i 와 달라야 한다는 것이다.<code class="highlighter-rouge">check[i]==check[a[i][j]]</code> 인지 확인해야 한다.</strong></p>

<p><br />
<br /></p>

<hr />

<h3 id="단지번호붙이기-2667번-문제">단지번호붙이기 (2667번 문제)</h3>

<p>연결요소의 개수를 구하는 문제와 완벽하게 동일하다.
<strong>특이한 점은 미리 인접행렬이 나와있다는 점(이걸 사용하면 됨), 또 노드 끼리 이어져 있는 방향이 4방향(위,아래,왼쪽,오른쪽) 이라는 점이다.</strong></p>

<p>하나의 노드에서 연결되어 있는 노드를 확인 할 때, 4방향을 for 문으로 탐색하면 된다. 만약 아직 check 되지 않은 곳(이 문제에서는 값이 1)이라면 탐색하고, 갈 수 없는 곳(이 문제에서는 값이 0) 이라면 넘어가면 된다.</p>

<p><br /></p>

<p><strong>주의할 점은 4방향의 연결된 노드를 탐색하기 전에, 그 값이 행렬의 범위를 벗어나는지 확인해 보아야 한다. 또한 단지의 크기를 구하기 위해서 dfs 가 한번 돌 때마다 카운트를 증가시켜야 하고, main 에서 dfs 를 실행할 때마다 단지의 개수(연결요소의 개수)를 증가시키는 작업을 동시에 해야 한다.</strong></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">26</span><span class="p">][</span><span class="mi">26</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">check</span><span class="p">[</span><span class="mi">26</span><span class="p">][</span><span class="mi">26</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>  <span class="c1">// 탐색 방향을 저장해 둔다.</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>  <span class="c1">// 4방향을 나타낸다.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">danzi</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dct</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 노드를 거칠 때마다 단지의 크기를 증가시킨다.</span>
    <span class="n">check</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 유효한 행렬 범위인지 확인하고 dfs 를 진행한다.</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>  
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%1d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
                <span class="n">danzi</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dct</span><span class="p">);</span>
                <span class="c1">// 단지의 크기를 초기화 시켜주고, 단지의 개수를 증가시킨다.</span>
                <span class="n">dct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">ct</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">ct</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">danzi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">danzi</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">danzi</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">danzi</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>

<hr />

<h3 id="섬의-개수-4963번-문제">섬의 개수 (4963번 문제)</h3>

<p>이 문제는 단지 구하기 문제랑 완전 똑같은 문제인데, 조금 더 업그레이드 된 버전이다.
이전 문제가 4방향의 연결된 노드를 탐색하며 진행한다면, 이번에는 대각선까지 포함하여 8방향으로 진행된다.</p>

<p><strong>여기서도 마찬가지로 주의할 점은 8가지 방향을 탐색할 때, 배열의 범위를 잘 파악해주는 것이다.</strong></p>

<p><em>코드는 다음과 같다.</em></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">w</span><span class="p">,</span><span class="n">h</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">50</span><span class="p">][</span><span class="mi">50</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">check</span><span class="p">[</span><span class="mi">50</span><span class="p">][</span><span class="mi">50</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">check</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nx</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span><span class="o">&lt;</span><span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span><span class="o">&lt;</span><span class="n">w</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">50</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">50</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">w</span><span class="p">,</span><span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">w</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">h</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">w</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">scanf</span><span class="p">(</span><span class="s">"%1d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">h</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">w</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span> <span class="o">&amp;&amp;</span>  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
                    <span class="n">ct</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">ct</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h2 id="본격적인-bfs">본격적인 BFS</h2>

<p><strong>BFS는 모든 가중치가 1일때, 최단거리를 구하는 알고리즘이다</strong></p>

<ul>
  <li>최단거리 문제 (최소 비용 문제) : 간선의 가중치가 1이어야 한다</li>
  <li>정점과 간선의 개수가 적어야 한다(시간제한, 메모리제한)</li>
</ul>

<p>다음은 BFS 의 문제이다.</p>

<h3 id="미로-탐색-2178번-문제">미로 탐색 (2178번 문제)</h3>

<p>가장 빠른 길을 구하는 문제이다.</p>

<p><code class="highlighter-rouge">DFS</code> 는 시작에서 도착으로 <code class="highlighter-rouge">갈수 있냐 없냐</code> 만 판단하기 때문에 이 문제를 해결할 수 없다. <code class="highlighter-rouge">DFS</code> 는 매번 가능한 모든 경우 중 하나를 선택해서 끝까지 갔다가, 다시 돌아오는 방식을 취하기 때문에, 가장 빠른 길을 구할 수 없다.</p>

<p><code class="highlighter-rouge">BFS</code> 는 시작에서 도착까지 방문한 칸의 최소개수인 경로를 구할 수 있다. 왜냐하면 <code class="highlighter-rouge">BFS</code> 는 한꺼번에 한 정점에서 가능한 노드를 그다음 큐에 넣고, 동시에 진행하기 때문에, 몇번째 시도에서 도착 노드에 도달했는지 파악 할 수 있으며, 이게 즉 최소 거리(개수) 가 된다.</p>

<p><br /></p>

<p><strong>이 문제에서 중요한 점은, 하나의 정점에서 다른 갈 수 있는 정점들을 찾을 때, 이존의 cost(값) 에서 1씩 더해주며 다음 정점들에 값을 할당해야 한다는 것이다. 즉 BFS의 탐색에서 다음 노드를 찾으면 기준 노드의 값 + 1 을 할당해 준다는 것이다.</strong></p>

<p><em>설명이 어려우니 아래의 코드를 보고 이해하자</em></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">check</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">sx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sy</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="n">sy</span><span class="p">));</span>
    <span class="n">check</span><span class="p">[</span><span class="n">sx</span><span class="p">][</span><span class="n">sy</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">//printf("-----------\n");</span>
        <span class="o">/*</span> <span class="err">업데이트</span> <span class="err">되는</span> <span class="err">판의</span> <span class="err">모습을</span> <span class="err">살펴</span> <span class="err">볼</span> <span class="err">수</span> <span class="err">있다</span><span class="p">.(</span><span class="n">debugging</span> <span class="err">용</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//printf("-----------\n");</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nx</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span><span class="o">&lt;</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//printf("nx ny : %d %d \n",nx,ny);</span>
                    <span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="c1">// 여기서 이전의 값에 +1 을 한 값을 다음 노드에 할당한다</span>
                    <span class="n">p</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// n,m 의 값을 출력한다. 이것은 즉 여기까지 오는데 걸린 최소 거리가 된다.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%1d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">bfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>

<hr />

<h3 id="숨바꼭질-1697번-문제">숨바꼭질 (1697번 문제)</h3>

<p><em>그래프 문제가 아닌거 같은데, 그래프로 변환해서 풀어야 하는 문제이다.</em></p>

<p>이 문제에서 N에서 K까지 가는 최소 시간을 구해야 한다.</p>

<blockquote>
  <p>X 와 연결된 노드는 X+1,X-1,2 * X 가 있다.</p>
</blockquote>

<p>이 문제는 다음 노드로 이동할 수 있는 가지수가 다음과 같이 수식으로 나타나 있기 때문에, 따로 <strong>인접리스트나 행렬을 만들지 않아도 된다.</strong> 바로 BFS에 적용하면 된다.(if else 또는 switch case 로). 또한 몇번만에 방문했는지 확인하기 위해 추가적으로 <code class="highlighter-rouge">dist[i]</code> 전역 배열 변수가 필요하다.</p>

<p>마찬가지로 dist[시작점] 에 0을 저장하고, 다음 노드에 하나씩 더해가며 queue 에서 마지막 도착점이 나올 때까지 bfs를 진행한다. 마지막에는 dist[도착점] 의 값을 출력해주면 된다.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;queue&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">check</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">check</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">==</span><span class="n">k</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">[</span><span class="n">f</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">f</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">check</span><span class="p">[</span><span class="n">f</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">[</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">check</span><span class="p">[</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">check</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
    <span class="n">bfs</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>

<hr />

<h2 id="가중치가-다른-경우의-bfs">가중치가 다른 경우의 BFS</h2>

<p><img src="https://github.com/jgtonys/upload_test/blob/master/screenshot-Fri%20Jul%2019%202019%2019:41:00%20GMT%2B0900%20%28KST%29.png?raw=true" alt="image.png" /></p>

<p>파란 간선을 한번만 쓸 수 있기 때문에 A-&gt;B 로 가는 두개의 경로는 다른 경로이다. <strong>파란 간선을 써버렸다면 그 이후에는 쓸수없고, 쓰지 않았다면 그 후에 쓸 수 있기 때문.</strong></p>

<p>따라서 파란간선을 사용한 횟수에 따라서 그래프를 다르게 구해주어야 한다.</p>

<p><img src="https://github.com/jgtonys/upload_test/blob/master/screenshot-Fri%20Jul%2019%202019%2019:43:01%20GMT%2B0900%20%28KST%29.png?raw=true" alt="image.png" /></p>

<p>위의 예제는 가중치가 다른 그래프에서 정점을 쪼개는 연습을 해본 것이다. 다음 이모티콘 문제를 통해 연습해보자.</p>

<p><br />
<br /></p>

<hr />

<h3 id="이모티콘-14226번-문제">이모티콘 (14226번 문제)</h3>

<p>이 문제는 클립보드에 있는 이모티콘의 개수에 따라 다음 정점이 정해지게 된다.</p>

<p><strong>중요한 포인트 : 이모티콘이 클립보드에 몇개가 저장되어 있는가</strong></p>

<p>정점을 (화면개수, 클립보드개수) 로 표현한다고 치자
다음과 같이 노드 사이의 로직을 정리할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>복사 연산 : (s, c) -&gt; (s, s)
붙여넣기 연산 : (s,c) -&gt; (s+c,c)
삭제 연산: (s,c) -&gt; (s-1,c)
</code></pre></div></div>

<p>이 연산을 적용하여 bfs 를 수행한다. 여기에서 클립보드에 있는 값은, 결과자체에 중요한 값이 아니지만, 연산에 있어서 필요한 값이다. <strong>따라서 정점(노드) 는 클립보드의 값이 포함된 (s,c) 로 구성하되, 결과 최솟값을 구할 때는 마지막에 모든 s==S 인 pair 중에 가장 cost 가 작은 값을 골라주면 된다.</strong></p>

<p><em>코드는 다음과 같다</em></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;queue&gt;
#include &lt;utility&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">S</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="mi">1001</span><span class="p">][</span><span class="mi">1001</span><span class="p">];</span>

<span class="c1">// 노드의 이동 목록</span>
<span class="c1">// (s,c) =&gt; (s,s)</span>
<span class="c1">// (s,c) =&gt; (s+c,c)</span>
<span class="c1">// (s,c) =&gt; (s-1,c)</span>
<span class="c1">// 초기값은 (1,0)</span>
<span class="kt">void</span> <span class="nf">bfs</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//초기값이므로 이동x</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">c</span><span class="o">&lt;=</span><span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">c</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">c</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 마지막에 모든 S 를 만들 수 있었던 경우의 수 중 가장 작은 cost 를 선택한다</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1001</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">S</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">==-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">S</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">S</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dist</span><span class="p">));</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">S</span><span class="p">);</span>
    <span class="n">bfs</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>

<hr />

<h2 id="덱-사용하기">덱 사용하기</h2>

<p><em>Double Ended Queue</em> : 양쪽에서 push pop 을 진행하는 큐</p>

<p><br />
<br /></p>

<hr />

<h3 id="숨바꼭질3-13549번-문제">숨바꼭질3 (13549번 문제)</h3>

<h4 id="기존의-bfs-를-활용한-방법큐-두개-사용">기존의 BFS 를 활용한 방법(큐 두개 사용)</h4>

<p><code class="highlighter-rouge">BFS</code> 문제는 모든 가중치가 1일때(같을때) 풀 수 있다고 했는데, 가중치가 0인 경우에도 풀 수 있는 경우가 있다.</p>

<p>이 문제에서는 순간이동이 0초가 걸린다.</p>

<p>예시로 5에서 17로 가는 경우 0~20까지만 위치가 있다고 가정한다면, 0초가 걸리는 queue 와 1초가 걸리는 queue 를 나누어서 풀어주면 된다.</p>

<p>처음 시도에서 0초가 걸리는 작업은 10이고, 1초가 걸리는 작업은 4와 6이다.</p>

<p><img src="https://github.com/jgtonys/upload_test/blob/master/screenshot-Fri%20Jul%2019%202019%2020:33:26%20GMT%2B0900%20%28KST%29.png?raw=true" alt="image.png" /></p>

<p>그 다음 시도에서 0초가 걸리는 작업은 20이고, 1초가 걸리는 작업은 19과 21이다.</p>

<p><img src="https://github.com/jgtonys/upload_test/blob/master/screenshot-Fri%20Jul%2019%202019%2020:33:58%20GMT%2B0900%20%28KST%29.png?raw=true" alt="image.png" /></p>

<p>마지막 시도에서는 0초의 작업이 불가능하다(20을 넘어가기 때문에). 따라서 1초의 작업 19만 가능하게 된다.</p>

<p><img src="https://github.com/jgtonys/upload_test/blob/master/screenshot-Fri%20Jul%2019%202019%2020:34:49%20GMT%2B0900%20%28KST%29.png?raw=true" alt="image.png" /></p>

<p>이 작업이 끝나게 되면 0초 큐에 존재하는 모든 작업을 수행했다고 보아도 된다. 이제 남는 것은 1초큐에 있는 작업인데, 이 1초큐에 있는 작업을 바탕으로 다시 2초큐를 만들어 하나씩 똑같이 수행하면 된다.</p>

<p>1초 큐에 있는 4를 0초 작업 하여 8을 추가하고, 2초 큐에 3을 추가한다. 5는 추가할 수 없는데, 그 이유는 이미 방문했기 때문(check 배열에 true 로 존재)이다.</p>

<p><img src="https://github.com/jgtonys/upload_test/blob/master/screenshot-Fri%20Jul%2019%202019%2020:36:33%20GMT%2B0900%20%28KST%29.png?raw=true" alt="image.png" /></p>

<p><strong>여기서 queue 를 계속해서 만드는 것이 아니라, 0초큐가 비어있게 되면 1초큐의 내용을 가져다가 붙여넣고, 새롭게 1초 큐를 만들어 주는 방식으로 queue를 두개만 사용한다</strong></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next_queue</span><span class="p">;</span>
<span class="c1">// BFS 처리</span>
<span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">next_queue</span><span class="p">;</span>
    <span class="n">next_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// 비어있는 큐 생성</span>
<span class="p">}</span></code></pre></figure>

<p><br /></p>

<h4 id="덱을-사용한-방법">덱을 사용한 방법</h4>

<p><code class="highlighter-rouge">BFS</code> 는 어떤 기준을 중심으로 가중치가 1차이 나는 문제를 해결할 수 있다. 따라서 덱을 사용해서 가중치가 0인(순간이동) 작업을 기준 노드의 앞에 배치하고, 1인 작업을 기준 노드의 뒤에 배치하는 방식으로 진행하면 그대로 BFS를 사용하여 풀 수 있다.</p>

<p><em>이게 왜 가능한지 해석해보면, BFS에서 같은 가중치(같은 레벨)를 가지는 노드들은 뭐가 먼저 실행되어도 상관이 없기 때문에, 0초 작업인 순간이동을 queue 의 앞에 배치하면 결국 현재 노드와 동일한 레벨의 원소를 하나 더 만드는 것이 되기 때문에 가능하다</em></p>

<p>코드는 <code class="highlighter-rouge">숨바꼭질 코드</code>와 정확하게 동일하지만, deque 를 사용하기 때문에 일반적인 <code class="highlighter-rouge">pop()</code> 이 <code class="highlighter-rouge">pop_front()</code> 가 된다는 점과 <code class="highlighter-rouge">push()</code> 가 <code class="highlighter-rouge">push_front()</code>, <code class="highlighter-rouge">push_back()</code>으로 나누어 진다는 것을 명심해야 한다.</p>

<p><br />
<br /></p>

<hr />

<h3 id="알고스팟-1261번-문제">알고스팟 (1261번 문제)</h3>

<p><img src="https://github.com/jgtonys/upload_test/blob/master/screenshot-Fri%20Jul%2019%202019%2020:57:38%20GMT%2B0900%20%28KST%29.png?raw=true" alt="image.png" /></p>

<p>0 은 빈방이라 그냥 이동하고 1은 부수면서 이동하는 것인데, 시작점에서 도착점까지 <code class="highlighter-rouge">최소로 벽을 부신 횟수</code>를 구해야 한다.</p>

<p>여기서 빈방을 이동하는 것은, 가중치가 없다(0). 벽을 부수는 행위는 가중치가 1이다.</p>

<p><strong>그렇다면 덱을 이용해서 가중치가 없는 노드의 이동은 큐의 앞에 배치하고, 가중치가 1인 노드의 이동을 큐의 뒤에 배치하면서 BFS를 풀어나가면 된다.</strong></p>

<p><em>코드는 다음과 같다</em></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;utility&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">check</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">deque</span><span class="o">&lt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span> <span class="c1">//시작값</span>
    <span class="n">check</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">//시작값 초기화</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nx</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span><span class="o">&lt;</span><span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">];</span>                   
                    <span class="n">q</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">check</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">dist</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%1d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">bfs</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>

<hr />

<h3 id="벽-부수고-이동하기-2206번-문제">벽 부수고 이동하기 (2206번 문제)</h3>

<p>벽은 한번만 부수고 지나갈 수 있다. 따라서 벽을 부수는 행위에 따라 노드의 이동이 달라지기 때문에 이 행동을 기준으로 노드의 로직을 생성한다.</p>

<p>(r,c,f) 에서 r 과 c 를 행렬의 위치로 나타내고, f를 벽이 부순적이 있는지 없는지를 나타내는 변수로 두고 로직을 생성하자. 여기서 pair&lt;int,int,int&gt; 를 생성해주면 된다.</p>

<p><strong>앞 뒤 좌 우 4방향으로 움직일 수 있는 것은 제외하고 로직을 기술해 보면</strong></p>

<ul>
  <li>(r,c,0) -&gt; 벽을 부수거나 부수지 않고 이동이 가능</li>
  <li>(r,c,1) -&gt; 벽을 부수지 않고만 이동이 가능</li>
</ul>

<p>이렇게 나타낼 수 있다.</p>

<p>나머지는 동일하게 BFS 를 진행해 주면 된다.</p>

<p><br />
<br /></p>

<hr />

<h3 id="탈출-3055번-문제">탈출 (3055번 문제)</h3>

<p>여기서는 고슴도치가 이동함과 동시에 물이 차게 된다. 두개의 BFS를 동시에 구하는 것이 아니라, 물이 차는 시간에 대한 BFS를 모두 구해준 다음, 그 구해진 판과 고슴도치의 경로를 비교하여 구하게 된다.</p>

<ol>
  <li>먼저 물이 차는 BFS를 생성한다</li>
  <li>고슴도치가 이동하는 BFS를 구하는데, 이동했을때의 cost 가 물이 찬 cost 보다 작아야만 이동이 가능하다.</li>
</ol>

<p>순차적으로 BFS 를 구해준다고 생각하면 쉽다.</p>

<p><strong>코드는 다음과 같다.</strong></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">water</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'D'</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">water</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">water</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="n">sy</span><span class="p">));</span>
<span class="n">d</span><span class="p">[</span><span class="n">sx</span><span class="p">][</span><span class="n">sy</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">water</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">water</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">d</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>


  </article>
</div>

<div class="related">
  <h2>Other Posts</h2>
  <ul class="related-posts">
    
    <li>
      <h3>
        <a href="/blog/2019/08/13/docker-image-upload/">
          Docker 이미지 만들기 & 배포하기
          <small>13 Aug 2019</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/blog/2019/07/20/jekyll-code-block-liquid-escape/">
          Jekyll Code Block 에서 liquid tag Escape
          <small>20 Jul 2019</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/algorithm/2019/07/18/algorithm(6)/">
          알고리즘 - 브루트 포스(중급)
          <small>18 Jul 2019</small>
        </a>
      </h3>
    </li>
    
  </ul>
</div>


<div class="comments">
  <h2>Comments</h2>
  <div id="disqus_thread"></div>
  <script>
    /*
var disqus_config = function () {
  this.page.url = 'http://0.0.0.0:4000/algorithm/2019/07/18/algorithm(4)/'; // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = '/algorithm/2019/07/18/algorithm(4)'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};*/
    (function() {
      var d = document,
        s = d.createElement('script');
      s.src = '//jgtonys.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if (target === toggle) {
            checkbox.checked = !checkbox.checked;
            e.preventDefault();
          } else if (checkbox.checked && !sidebar.contains(target)) {
            /* click outside the sidebar when sidebar is open */
            checkbox.checked = false;
          }
        }, false);
      })(document);
    </script>
    
    <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110053740-1', 'auto');
ga('send', 'pageview');
    </script>
    
  </body>
  
  <script id="dsq-count-scr" src="//jgtonys.disqus.com/count.js" async></script>
  
</html>
